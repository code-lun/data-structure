**括号匹配:**

遇到左括号直接压栈

遇到右括号,出栈一个元素看是否匹配,如果不匹配则失败

成功则继续遍历表达式

若最后栈不为空,也表示匹配失败(有单身左括号)   例如: (()  ([()]

**中缀表达式转后缀表达式:**

涉及两个栈,一个opr栈(运算符栈,也可以叫他临时栈)最后opr栈为空栈,一个opd栈(操作数栈,所有运算符都会压入这个栈,不过不是马上压入)

核心逻辑:先进行括号匹配(失败则结束算法)

括号的处理不做赘述

*+-*/涉及优先级的问题,这里也是一个关键点*

此时opr栈就发挥作用了

一般情况: 假设opr栈中运算符都叫做a,读到的运算符都叫b,如果a的优先级大于等于b,则出栈(有多少出多少,按顺序出栈)  出栈的元素按顺序压入opd栈中,先出先压

读到的第一个运算符(a)直接入栈,下一个读到的运算符(b),如果a的优先级大于等于b,则弹出a,b压栈,否则b直接压栈   如果b直接压栈此时栈中就有两个运算符了,第三次读到运算符的话是一定会有元素出栈的(ab都入栈的情况只能是a为+-之一 b为*/之一)  同样出栈的元素压入opd栈中

读到右括号:

opr栈一直进行出栈操作,知道遇到对应的左括号,注意:左括号不入栈

**计算后缀表达式:**

这个只需要涉及一个栈(存有后缀表达式),遍历这个栈(可能会涉及转置栈)

核心逻辑:操作数直接入栈,遇到运算符,弹出栈中两个元素

第一个弹出的元素作为右操作数,第二个作为左操作数,运算符对应相应的运算

画个图会更好理解(竖着的栈)